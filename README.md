# Simple Rule Parser

The following repository contains an evaluator for a simple rule language. The underlying parser was generated with [ANTLR4](https://www.antlr.org/)
which converts a source into an AST (abstract syntax tree) of expression rules. Each rule provides an evaluation
method to traverse the AST and to compute the result of the expression.

## Grammar

The grammar of the simple rule language is located as follows:
- Lexer grammar: src/main/antlr4/io/github/dvischi/expr_rule_parser/ExprRuleLexer.g4
- Parser grammar: src/main/antlr4/io/github/dvischi/expr_rule_parser/ExprRuleParser.g4

It supports the following expressions:

| Expression                   | Example        |
| ---------------------------- | -------------- |
| Boolean                      | `true`         |
| Integer                      | `42`           |
| String                       | `"test"`       |
| List (of integers/strings)   | `[42, "test"]` |
| Variable                     | `a`            |
| Function                     | `f(1)`         |

A boolean or an integer can also be expressed using one (or a combination) of the below operators (all with a left-to-right associativity):

| Precedence  | Type                      | Operator     | Example                      |
| ----------- | ------------------------- | ------------ | ---------------------------- |
| 1 (High)    | Multiplicative Operators  | *            | `1 * 2`                      |
|             |                           | /            | `1 / 2`                      |
| 2           | Additive Operators        | +            | `1 + 2`                      |
|             |                           | -            | `1 - 2`                      |
| 3           | Relational Operators      | >            | `1 > 2`                      |
|             |                           | <            | `1 < 2`                      |
|             |                           | ==           | `1 == 2`                     |
|             |                           | !=           | `1 != 2`                     |
|             |                           | contains     | `[1,2] contains 1`           |
|             |                           | contains all | `[1,2,3] contains all [1,3]` |
| 4           | Logical Not Operator      | not          | `not [1,2] contains 1`       |
| 5           | Logical And Operator      | and          | `true and false`             |
| 6 (Low)     | Logical Or Operator       | or           | `true or false`              |

Note: parentheses can be used to overwrite the operator precedences, e.g.: `(1 + 1) * 3 == 6`.

In the global scope, expressions can be used by the following statements:

| Statement           | Definition                                                    | Example                               |
| ------------------- | ------------------------------------------------------------- | ------------------------------------- |
| Variable Definition | `var <variable_name> := <expression>;`                        | `var variable_name := 42;`            |
| Function Definition | `func <function_name> := (<parameter_list>) -> <expression>;` | `func function_name := (i,j) -> i+j;` |
| Rule Definition     | `rule <rule_name> := <expression>;`                           | `rule rule_name := f(a);`             |

The definition of rules is the main purpose of this simple language (which maps a rule name with an expression).
The variables and functions, on the other hand, represent reusable modules for expressions.

The src/test/resources/test_rules.txt file contains a complete example, used for the unit tests:

```
var i := 1+1+1+1;
var j := 4;
func f := (i,j) -> i / j;
func g1 := (i) -> g2(i+1);
func g2 := (i) -> i+1;
rule rule1 := f(i,j) * 10;
rule rule2 := ["a",1,2] contains "a";
rule rule3 := ["a",1,2] contains all ["a",3];
rule rule4 := 20/2 > f(20,2);
rule rule5 := g1(g1(2));
```

## Parser Generation

The lexer and parser for the simple rule grammar can be generated by executing one of the following scripts:
- Python:        scripts/generate_lexer_and_parser.py
- Bash (Linux):  scripts/generate_lexer_and_parser.sh
- CMD (Windows): scripts/generate_lexer_and_parser.bat

All generated files are stored in the following folder:
- src/gen/java/io/github/dvischi/expr_rule_parser

Note: this step is not required when using Maven which automatically runs the Python script during the generate-sources phase.

## Testing

A few simple unit tests can be executed with the following command: `mvn test`.

## Build Targets

The provided code can be used either as an (1) external library for another project or (2) as a standalone command line tool for testing purposes.

1. Build the library as...
    * slim JAR: `mvn package`
2. Build the command line tool as...
    * slim JAR: `mvn package -Darchive.manifest.addclasspath=true -Darchive.manifest.classpathprefix=dependency`
    * fat JAR: `mvn package assembly:single`

## Command Line Tool Usage

The command line tool can be executed ...

1. directly with Maven: `mvn exec:java -Dexec.mainClass=io.github.dvischi.expr_rule_parser.ExprRuleEvaluator -Dexec.args="<parameters>"`
2. via the slim JAR:
    1. by copying the required dependencies: `mvn dependency:copy-dependencies -DoutputDirectory=${project.build.directory}/dependency -DincludeScope=runtime`
    2. running the slim JAR: `java -jar target/antlr4-expression-rule-parser-1.0.0-SNAPSHOT.jar <parameters>`
3. via the fat JAR: `java -jar target/antlr4-expression-rule-parser-1.0.0-SNAPSHOT-jar-with-dependencies.jar <parameters>`

... which accepts the following parameters ...

- `--help`: shows the help message
- `<source_path> [--printCstTraversal] [--printAstTraversal]`: evaluates the content of a file located at <source_path> and, optionally, outputs the traversal of the concrete/abstract syntax tree (CST/AST)

The following example reads the rules used for the unit tests, evaluates them and prints the traversal of the concrete syntax tree (CST) in the console.
`java -jar target/antlr4-expression-rule-parser-1.0.0-SNAPSHOT-jar-with-dependencies.jar src/test/resources/test_rules.txt --printCstTraversal`

## Attribution

The lexer, parser, listener and visitor for the grammar were generated using ANTLR4 which is released under BSD-3-Clause License.

For further details, please refer to the THIRD_PARTY_LICENSES.txt.
